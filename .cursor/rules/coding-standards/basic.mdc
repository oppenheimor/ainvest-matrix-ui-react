---
description: 
globs: 
alwaysApply: true
---
### 基本代码规范

- 注释：希望你总是在必要的地方编写有效的代码注释，注释的中英文之间要加空格；
- HTML 标签：使用面向 SEO 友好、有语义的 HTML 标签;

### 设计模式

- **高阶组件（HOCs）**：用于包裹组件以实现逻辑复用（需谨慎使用，推荐优先考虑 Hook）；
- **渲染属性（Render Props）**：通过值为函数的 prop 来实现代码共享；
- **复合组件（Compound Components）**：具有隐式协作关系的组件群（例如 `Tabs` 和 `Tab`）；
- **Hooks**：可在函数式组件间共享的带状态逻辑

### 推荐实践方案

- **表单处理**：推荐使用受控组件配合本地状态管理，或采用 `Formily`、`React Hook Form` 等表单库；
- **API 请求**：使用 `useEffect` 钩子发起 API 调用并管理加载状态；
- **条件渲染**：简单条件推荐使用短路运算（&&）或三元表达式；复杂场景应拆分为独立组件；
- **列表渲染**：渲染列表时必须提供唯一且稳定的 `key` 属性；
- **props 设计**：组件的 props 参数名必须具有语义化，避免使用 `id`、`data`、`value`、`type` 等模糊不清的命名；

### 反模式与代码异味

- **禁止直接修改状态**：必须使用 `setState` 或状态更新函数来修改状态；
- **禁止书写行内样式**：推荐使用 `tailwindcss` 来完成样式编写；
- **禁止过度设计**：避免对简单问题使用复杂解决方案；
- **禁止滥用 `useEffect`**：禁止在同一个组件中频繁滥用 `useEffect`；
- **避免直接操作DOM**：避免直接操作 `DOM` 元素，应当让 `React` 处理视图更新；
- **避免属性透传**：避免在多层级组件中传递未被实际使用的 `props`

### 状态管理最佳实践

- **本地状态**：使用 `useState` 管理组件专属状态；
- **Context API**：使用 useContext 实现多组件共享的全局状态，但避免用于高频更新的数据；
- **Redux/Mobx**：大型应用中的复杂状态管理推荐使用这些库；
- **Recoil/Zustand**：Redux 的轻量级替代方案，通常更易配置和使用；
- **不可变数据**：始终以不可变方式处理状态，避免意外副作用

开发组件的时候优先使用 `本地状态` 和 `Context API`! 当状态管理比较复杂的时候再考虑使用 `Recoil`、`Zustand`、`Redux`、`Mobx` 等。

## 错误处理模式

- **Try-Catch 代码块**：在异步操作和事件处理器中使用 `try-catch` 代码块处理错误；
- **错误边界（Error Boundaries）**：使用错误边界包裹组件，捕获渲染过程中的错误，避免应用崩溃；
- **集中式错误日志**：实现集中式错误日志服务，用于追踪错误并提升应用稳定性

其中 `错误边界（Error Boundaries）` 和 `集中式错误日志` 看情况进行使用，一般不需要使用。

## 性能优化

### 优化技巧

- **记忆化（Memoization）**：使用 `React.memo`、`useMemo` 和 `useCallback` 避免不必要的重新渲染和重复计算；
- **虚拟化（Virtualization）**：使用 `react-window` 或 `react-virtualized` 等库高效渲染大型列表或表格；
- **防抖/节流（Debouncing/Throttling）**：限制函数执行频率（例如输入框场景）；
- **代码分割（Code Splitting）**：通过 `React.lazy` 和 `Suspense` 实现按需加载代码

### 内存管理

- **避免内存泄漏**：在 `useEffect` 的清理函数中移除事件监听器、定时器和订阅；
- **释放无用对象**：及时释放不再需要的大型内存对象；
- **垃圾回收机制**：理解 `JavaScript` 垃圾回收原理，避免创建不必要的对象

### 渲染优化

- **最小化状态更新**：避免触发不必要重新渲染的状态更新；
- **批量更新**：使用 `ReactDOM.unstable_batchedUpdates` 将多个状态更新合并为单次更新；
- **Key 值规范**：确保 `key` 在多次渲染间保持唯一且稳定

### 懒加载策略

- 基于路由的懒加载：当用户导航到特定路由时加载对应组件；
- 基于组件的懒加载：在组件即将渲染时进行加载；
- 可视区域加载（Intersection Observer）：当组件进入视口可见区域时触发加载

## 常见陷阱与疑难问题

### 高频错误

- **列表键值缺失**：渲染列表时未提供唯一且稳定的 `key` 属性；
- **错误的状态更新**：直接修改状态而非使用 `setState` 或状态更新函数；
- **`useEffect`** 依赖项遗漏：未在 `useEffect` 钩子的依赖数组中包含全部依赖项；
- **状态过度使用**：将派生数据存储在状态中而非实时计算

### 边界情况处理

- **异步状态更新**：在异步操作中正确处理状态更新；
- **竞态条件**：发起多个 `API` 调用时预防竞态条件；
- **事件处理器错误处理**：妥善处理事件处理器中的错误以避免程序崩溃